Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp14872.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\nimport org.firstinspires.ftc.teamcode.res.Gyro;\r\nimport org.firstinspires.ftc.teamcode.robotData.GlobalData;\r\nimport org.firstinspires.ftc.teamcode.robotSubSystems.drivetrain.Drivetrain;\r\nimport org.firstinspires.ftc.teamcode.utils.Vector;\r\n\r\n@TeleOp(name = \"TeleOp14872\")\r\npublic class TeleOp14872 extends LinearOpMode {\r\n\r\n    private ElapsedTime timer = new ElapsedTime();\r\n\r\n    @Override\r\n    public void runOpMode() throws InterruptedException {\r\n        Gyro.init(hardwareMap);\r\n        Drivetrain.init(hardwareMap);\r\n\r\n        GlobalData.isAutonomous = false;\r\n\r\n        waitForStart();\r\n\r\n        while (!isStopRequested()){\r\n            GlobalData.currentTime = timer.milliseconds();\r\n            Drivetrain.operate(new Vector(gamepad1.left_stick_x, gamepad1.left_stick_y, gamepad1.left_trigger - gamepad1.right_trigger));\r\n\r\n            GlobalData.deltaTime = GlobalData.currentTime - GlobalData.lastTime;\r\n\r\n            GlobalData.lastTime = GlobalData.currentTime;\r\n            telemetry.update();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp14872.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp14872.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp14872.java	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp14872.java	(date 1668410896864)
@@ -19,7 +19,7 @@
     public void runOpMode() throws InterruptedException {
         Gyro.init(hardwareMap);
         Drivetrain.init(hardwareMap);
-
+        if(gamepad1.right_bumper) {Gyro.resetGyro();}
         GlobalData.isAutonomous = false;
 
         waitForStart();
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotSubSystems/drivetrain/Drivetrain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.robotSubSystems.drivetrain;\r\n\r\n\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\n\r\nimport org.firstinspires.ftc.teamcode.res.Gyro;\r\nimport org.firstinspires.ftc.teamcode.robotData.GlobalData;\r\nimport org.firstinspires.ftc.teamcode.utils.Vector;\r\n\r\npublic class Drivetrain {\r\n\r\n    private static final DcMotor[] motors = new DcMotor[4];\r\n\r\n    public static Vector lastVelocity = getVelocity_FieldCS();\r\n\r\n    public static void init(HardwareMap hardwareMap) {\r\n        //if (GlobalData.isAutonomous) drive = new SampleMecanumDrive(hardwareMap);\r\n        motors[0] = hardwareMap.get(DcMotor.class, \"lf\");\r\n        motors[1] = hardwareMap.get(DcMotor.class, \"rf\");\r\n        motors[2] = hardwareMap.get(DcMotor.class, \"lb\");\r\n        motors[3] = hardwareMap.get(DcMotor.class, \"rb\");\r\n\r\n        for (final DcMotor motor : motors) {\r\n            motor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        }\r\n    }\r\n    public static void operate(Vector velocity_W) {\r\n        final float robotAngle = (float) Math.toRadians(Gyro.getAngle());\r\n        Vector velocity_FieldCS_W;\r\n        if (!GlobalData.isAutonomous){\r\n            //field centric\r\n            //TODO: check if you need to insert the inverse angle into rotation function\r\n            velocity_FieldCS_W = velocity_W.rotate(-robotAngle);\r\n        } else {\r\n            velocity_FieldCS_W = velocity_W;\r\n        }\r\n        drive(velocity_FieldCS_W);\r\n    }\r\n\r\n    //TODO: write the velocity calculation\r\n    public static Vector getVelocity_FieldCS() {\r\n        return null;\r\n    }\r\n\r\n    public static Vector getAcceleration() {\r\n        Vector currentVelocity = getVelocity_FieldCS();\r\n\r\n        Vector deltaVelocity = currentVelocity.subtract(lastVelocity);\r\n        Vector acceleration = deltaVelocity.scale(1 / GlobalData.deltaTime);\r\n\r\n        lastVelocity = currentVelocity;\r\n        return acceleration;\r\n    }\r\n\r\n    public static void stop() {\r\n        for (DcMotor motor : motors) {\r\n            motor.setPower(0);\r\n        }\r\n    }\r\n\r\n    public static void drive(Vector drive) {\r\n        final double lfPower = drive.y + drive.x + drive.r;\r\n        final double rfPower = drive.y - drive.x - drive.r;\r\n        final double lbPower = drive.y - drive.x + drive.r;\r\n        final double rbPower = drive.y + drive.x - drive.r;\r\n        double highestPower = 1;\r\n        final double max = Math.max(Math.abs(lfPower),\r\n                Math.max(Math.abs(lbPower), Math.max(Math.abs(rfPower), Math.abs(rbPower))));\r\n        if (max > 1)\r\n            highestPower = max;\r\n        motors[0].setPower((lfPower / highestPower));\r\n        motors[1].setPower((rfPower / highestPower));\r\n        motors[2].setPower((lbPower / highestPower));\r\n        motors[3].setPower((rbPower / highestPower));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotSubSystems/drivetrain/Drivetrain.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotSubSystems/drivetrain/Drivetrain.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotSubSystems/drivetrain/Drivetrain.java	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotSubSystems/drivetrain/Drivetrain.java	(date 1668425722905)
@@ -28,15 +28,8 @@
     }
     public static void operate(Vector velocity_W) {
         final float robotAngle = (float) Math.toRadians(Gyro.getAngle());
-        Vector velocity_FieldCS_W;
-        if (!GlobalData.isAutonomous){
-            //field centric
-            //TODO: check if you need to insert the inverse angle into rotation function
-            velocity_FieldCS_W = velocity_W.rotate(-robotAngle);
-        } else {
-            velocity_FieldCS_W = velocity_W;
-        }
-        drive(velocity_FieldCS_W);
+
+        drive(velocity_W.rotate(robotAngle));
     }
 
     //TODO: write the velocity calculation
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Vector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.utils;\r\n\r\nimport org.firstinspires.ftc.teamcode.robotData.Constants;\r\n\r\npublic final class Vector {\r\n\r\n    public double x;\r\n    public double y;\r\n    public double r;\r\n\r\n    public Vector(final double x, final double y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public Vector(final double x, final double y, final double r) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.r = r;\r\n    }\r\n\r\n    public static Vector zero() {\r\n        return new Vector(0, 0);\r\n    } //returns Vector zero\r\n\r\n    public static Vector INF() { return new Vector(Constants.INF, Constants.INF); } // returns INF Vector\r\n\r\n    public double norm() {\r\n        return (double) Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    public double getAngle() {\r\n        if (x == 0 && y == 0) {\r\n            return 0;\r\n        } else {\r\n            return (double) Math.atan2(y, x);\r\n        }\r\n    }\r\n\r\n    public Vector scale(final double scalingFactor) {\r\n        return new Vector(x * scalingFactor, y * scalingFactor);\r\n    }\r\n\r\n    public Vector unit() {\r\n        if (x == 0 && y == 0) {\r\n            return this;\r\n        } else {\r\n            return scale(1 / norm());\r\n        }\r\n    }\r\n    // returns maagal hyehida\r\n    public static Vector unit(final double angle) {\r\n        return new Vector((double) Math.cos(angle) , (double) Math.sin(angle));\r\n    }\r\n\r\n    public static Vector fromAngleAndRadius(final double theta, final double radius) {\r\n        final double vectorX = (double) Math.cos(theta) * radius;\r\n        final double vectorY = (double) Math.sin(theta) * radius;\r\n        return new Vector(vectorX, vectorY);\r\n    }\r\n\r\n    public double dotProduct(final Vector other) { return x * other.x + y * other.y;}\r\n\r\n    public Vector rotate(final double theta) {\r\n        final double sinTheta = (double) Math.sin(theta);\r\n        final double cosTheta = (double) Math.cos(theta);\r\n\r\n        final double newX = x * cosTheta - y * sinTheta;\r\n        final double newY = x * sinTheta + y * cosTheta;\r\n\r\n        return new Vector(newX, newY);\r\n    }\r\n\r\n    public Vector rotate90(final boolean rotateCounterClockwise) {\r\n        if (!rotateCounterClockwise) {\r\n            return new Vector(-y, x);\r\n        } else {\r\n            return new Vector(y, -x);\r\n        }\r\n    }\r\n\r\n    public Vector abs() {\r\n        return new Vector(Math.abs(x), Math.abs(y));\r\n    }\r\n\r\n    public Vector add(final Vector other) {\r\n        return new Vector(x + other.x, y + other.y);\r\n    }\r\n\r\n    public Vector subtract(final Vector other) {\r\n        return new Vector(x - other.x, y - other.y);\r\n    }\r\n\r\n    public double project(final double angle) {\r\n        final Vector unitVector = unit(angle);\r\n        return dotProduct(unitVector);\r\n    }\r\n\r\n    public double project(final Vector other) {\r\n        final double otherNorm = other.norm();\r\n        return otherNorm != 0 ? dotProduct(other) / otherNorm : this.norm();\r\n    }\r\n\r\n    public static Vector longest(final Vector a, final Vector b) {\r\n        return a.norm() > b.norm() ? a : b;\r\n    }\r\n\r\n    public static Vector shortest(final Vector a, final Vector b) {\r\n        return a.norm() < b.norm() ? a : b;\r\n    }\r\n\r\n    public static Vector max(final Vector a, final Vector b) {\r\n        return new Vector(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    public static Vector min(final Vector a, final Vector b) {\r\n        return new Vector(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n\r\n    public static Vector sameXY(final double value) {\r\n        return new Vector(value, value);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"x: \" + x + \" y: \" + y;\r\n    }\r\n\r\n    public boolean equals(final Vector other) {\r\n        return x == other.x && y == other.y;\r\n    }\r\n\r\n    public static double angleDifference(final Vector a, final Vector b) {\r\n        final double normA = a.norm();\r\n        final double normB = b.norm();\r\n\r\n        if (normA == 0 || normB == 0)\r\n            return 0;\r\n\r\n        return (double) Math.acos(a.dotProduct(b) / (normA * normB));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Vector.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Vector.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Vector.java	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Vector.java	(date 1668425722890)
@@ -6,18 +6,11 @@
 
     public double x;
     public double y;
-    public double r;
 
     public Vector(final double x, final double y) {
         this.x = x;
         this.y = y;
     }
-
-    public Vector(final double x, final double y, final double r) {
-        this.x = x;
-        this.y = y;
-        this.r = r;
-    }
 
     public static Vector zero() {
         return new Vector(0, 0);
Index: .idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41_[Changes]/shelved.patch	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
+++ /dev/null	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
@@ -1,40 +0,0 @@
-Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/contours.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package org.firstinspires.ftc.teamcode.imageprocessing;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\r\nimport org.opencv.core.Core;\r\nimport org.opencv.core.Mat;\r\nimport org.opencv.core.MatOfPoint;\r\nimport org.opencv.core.MatOfPoint2f;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.core.Rect;\r\nimport org.opencv.core.Scalar;\r\nimport org.opencv.core.Size;\r\nimport org.opencv.imgproc.Imgproc;\r\nimport org.openftc.easyopencv.OpenCvPipeline;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class contours extends OpenCvPipeline {\r\n    //creates a telemetry\r\n    Telemetry telemetry;\r\n    //creates a material object\r\n    Mat mat = new Mat();\r\n    //sets the telemetry\r\n    public contours(Telemetry t) {\r\n        telemetry = t;\r\n    }\r\n    @Override\r\n    public Mat processFrame(Mat input) {\r\n        Mat mat = new Mat();\r\n        //turning image to binary image with the right settings\r\n        //binary = black & white image (the object is white)\r\n        //in this code we are turning the color yellow to white and else to black\r\n        Imgproc.cvtColor(input, mat, Imgproc.COLOR_RGB2HSV);\r\n        //blur (to remove noise)\r\n        Imgproc.blur(input, input, new Size(3, 3));\r\n        Scalar lowHSV = new Scalar(18 , 55 , 100);\r\n        Scalar highHSV = new Scalar(32, 255, 255);\r\n        Core.inRange(mat, lowHSV, highHSV, mat);\r\n        //list of contour points\r\n        List<MatOfPoint> contours = new ArrayList<>();\r\n        Mat hierarchy = new Mat();\r\n        //finding contours with a function from the openCV library\r\n        Imgproc.findContours(mat, contours, hierarchy , Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);\r\n        //draw contours\r\n        Imgproc.drawContours(input, contours, -1, new Scalar(255, 0, 0));\r\n        //framing all the requirements for the square\r\n        MatOfPoint2f[] contoursPoly  = new MatOfPoint2f[contours.size()];\r\n        //exports all of the contour vars to create a square (from the live pic)\r\n        Rect[] boundRect = new Rect[contours.size()];\r\n        Point[] centers = new Point[contours.size()];\r\n        float[][] radius = new float[contours.size()][1];\r\n        //searching for the right radius and center vector values\r\n        // (it turning the shape into many polygons and searching for the center and radius vectors) we will apply it later\r\n        for (int i = 0; i < contours.size(); i++) {\r\n            contoursPoly[i] = new MatOfPoint2f();\r\n            Imgproc.approxPolyDP(new MatOfPoint2f(contours.get(i).toArray()), contoursPoly[i], 3, true);\r\n            boundRect[i] = Imgproc.boundingRect(new MatOfPoint(contoursPoly[i].toArray()));\r\n            centers[i] = new Point();\r\n            Imgproc.minEnclosingCircle(contoursPoly[i], centers[i], radius[i]);\r\n        }\r\n        //drawing the actual square (it will show in white)\r\n        for (int i = 0; i < contours.size(); i++) {\r\n            Scalar color = new Scalar(255,255,255);\r\n            Imgproc.rectangle(input, boundRect[i].tl(), boundRect[i].br(), color, 2);\r\n        }\r\n\r\n        //find the largest contour prototype (by the size of the contour)\r\n        /*\r\n        double maxVal = 0;\r\n        int maxValIdx = 0;\r\n        for (int i = 0; i < contours.size(); i++) {\r\n            double contourArea = Imgproc.contourArea(contours.get(i));\r\n            if (maxVal < contourArea) {\r\n                maxVal = contourArea;\r\n                maxValIdx = i;\r\n            }\r\n        }\r\n        Imgproc.drawContours(input, contours, maxValIdx, new Scalar(0,255,0), 5);\r\n        */\r\n\r\n        return input;\r\n    }\r\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/contours.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/contours.java
---- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/contours.java	(revision 83fb8ebc0e166e860fc394bf1e472f8b7c17809a)
-+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/contours.java	(date 1666086112157)
-@@ -44,7 +44,7 @@
-         //draw contours
-         Imgproc.drawContours(input, contours, -1, new Scalar(255, 0, 0));
-         //framing all the requirements for the square
--        MatOfPoint2f[] contoursPoly  = new MatOfPoint2f[contours.size()];
-+        MatOfPoint2f[] contoursPoly = new MatOfPoint2f[contours.size()];
-         //exports all of the contour vars to create a square (from the live pic)
-         Rect[] boundRect = new Rect[contours.size()];
-         Point[] centers = new Point[contours.size()];
-@@ -63,9 +63,8 @@
-             Scalar color = new Scalar(255,255,255);
-             Imgproc.rectangle(input, boundRect[i].tl(), boundRect[i].br(), color, 2);
-         }
--
-         //find the largest contour prototype (by the size of the contour)
--        /*
-+
-         double maxVal = 0;
-         int maxValIdx = 0;
-         for (int i = 0; i < contours.size(); i++) {
-@@ -75,8 +74,8 @@
-                 maxValIdx = i;
-             }
-         }
-+
-         Imgproc.drawContours(input, contours, maxValIdx, new Scalar(0,255,0), 5);
--        */
- 
-         return input;
-     }
Index: .idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41__Changes_.xml	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
+++ /dev/null	(revision 558ab6da6736f1dff94fe6d84c188d18297b2ec4)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_18_10_2022_12_41_[Changes]" date="1666086130482" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_18_10_2022_12_41_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 18/10/2022 12:41 [Changes]" />
-</changelist>
\ No newline at end of file
