Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/tagdetection/AprilTagDetectionPipeline.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2021 OpenFTC Team\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npackage org.firstinspires.ftc.teamcode.imageprocessing.tagdetection;\r\n\r\nimport org.opencv.calib3d.Calib3d;\r\nimport org.opencv.core.CvType;\r\nimport org.opencv.core.Mat;\r\nimport org.opencv.core.MatOfDouble;\r\nimport org.opencv.core.MatOfPoint2f;\r\nimport org.opencv.core.MatOfPoint3f;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.core.Point3;\r\nimport org.opencv.core.Scalar;\r\nimport org.opencv.imgproc.Imgproc;\r\nimport org.openftc.apriltag.AprilTagDetection;\r\nimport org.openftc.apriltag.AprilTagDetectorJNI;\r\nimport org.openftc.easyopencv.OpenCvPipeline;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class AprilTagDetectionPipeline extends OpenCvPipeline {\r\n    private long nativeApriltagPtr;\r\n    private Mat grey = new Mat();\r\n    private ArrayList<AprilTagDetection> detections = new ArrayList<>();\r\n\r\n    private ArrayList<AprilTagDetection> detectionsUpdate = new ArrayList<>();\r\n    private final Object detectionsUpdateSync = new Object();\r\n\r\n    Mat cameraMatrix;\r\n\r\n    Scalar blue = new Scalar(7,197,235,255);\r\n    Scalar red = new Scalar(255,0,0,255);\r\n    Scalar green = new Scalar(0,255,0,255);\r\n    Scalar white = new Scalar(255,255,255,255);\r\n\r\n    double fx;\r\n    double fy;\r\n    double cx;\r\n    double cy;\r\n\r\n    // UNITS ARE METERS\r\n    double tagsize;\r\n    double tagsizeX;\r\n    double tagsizeY;\r\n\r\n    private float decimation;\r\n    private boolean needToSetDecimation;\r\n    private final Object decimationSync = new Object();\r\n\r\n    public AprilTagDetectionPipeline(double tagsize, double fx, double fy, double cx, double cy) {\r\n        this.tagsize = tagsize;\r\n        this.tagsizeX = tagsize;\r\n        this.tagsizeY = tagsize;\r\n        this.fx = fx;\r\n        this.fy = fy;\r\n        this.cx = cx;\r\n        this.cy = cy;\r\n\r\n        constructMatrix();\r\n\r\n        // Allocate a native context object. See the corresponding deletion in the finalizer\r\n        nativeApriltagPtr = AprilTagDetectorJNI.createApriltagDetector(AprilTagDetectorJNI.TagFamily.TAG_36h11.string, 3, 3);\r\n    }\r\n\r\n    @Override\r\n    public void finalize()\r\n    {\r\n        // Might be null if createApriltagDetector() threw an exception\r\n        if(nativeApriltagPtr != 0)\r\n        {\r\n            // Delete the native context we created in the constructor\r\n            AprilTagDetectorJNI.releaseApriltagDetector(nativeApriltagPtr);\r\n            nativeApriltagPtr = 0;\r\n        }\r\n        else\r\n        {\r\n            System.out.println(\"AprilTagDetectionPipeline.finalize(): nativeApriltagPtr was NULL\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Mat processFrame(Mat input)\r\n    {\r\n        // Convert to greyscale\r\n        Imgproc.cvtColor(input, grey, Imgproc.COLOR_RGBA2GRAY);\r\n\r\n        synchronized (decimationSync)\r\n        {\r\n            if(needToSetDecimation)\r\n            {\r\n                AprilTagDetectorJNI.setApriltagDetectorDecimation(nativeApriltagPtr, decimation);\r\n                needToSetDecimation = false;\r\n            }\r\n        }\r\n\r\n        // Run AprilTag\r\n        detections = AprilTagDetectorJNI.runAprilTagDetectorSimple(nativeApriltagPtr, grey, tagsize, fx, fy, cx, cy);\r\n\r\n        synchronized (detectionsUpdateSync)\r\n        {\r\n            detectionsUpdate = detections;\r\n        }\r\n\r\n        // For fun, use OpenCV to draw 6DOF markers on the image. We actually recompute the pose using\r\n        // OpenCV because I haven't yet figured out how to re-use AprilTag's pose in OpenCV.\r\n        for(AprilTagDetection detection : detections)\r\n        {\r\n            Pose pose = poseFromTrapezoid(detection.corners, cameraMatrix, tagsizeX, tagsizeY);\r\n            drawAxisMarker(input, tagsizeY/2.0, 6, pose.rvec, pose.tvec, cameraMatrix);\r\n            draw3dCubeMarker(input, tagsizeX, tagsizeX, tagsizeY, 5, pose.rvec, pose.tvec, cameraMatrix);\r\n        }\r\n\r\n        return input;\r\n    }\r\n\r\n    public void setDecimation(float decimation)\r\n    {\r\n        synchronized (decimationSync)\r\n        {\r\n            this.decimation = decimation;\r\n            needToSetDecimation = true;\r\n        }\r\n    }\r\n\r\n    public ArrayList<AprilTagDetection> getLatestDetections()\r\n    {\r\n        return detections;\r\n    }\r\n\r\n    public ArrayList<AprilTagDetection> getDetectionsUpdate()\r\n    {\r\n        synchronized (detectionsUpdateSync)\r\n        {\r\n            ArrayList<AprilTagDetection> ret = detectionsUpdate;\r\n            detectionsUpdate = null;\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    void constructMatrix()\r\n    {\r\n        //     Construct the camera matrix.\r\n        //\r\n        //      --         --\r\n        //     | fx   0   cx |\r\n        //     | 0    fy  cy |\r\n        //     | 0    0   1  |\r\n        //      --         --\r\n        //\r\n\r\n        cameraMatrix = new Mat(3,3, CvType.CV_32FC1);\r\n\r\n        cameraMatrix.put(0,0, fx);\r\n        cameraMatrix.put(0,1,0);\r\n        cameraMatrix.put(0,2, cx);\r\n\r\n        cameraMatrix.put(1,0,0);\r\n        cameraMatrix.put(1,1,fy);\r\n        cameraMatrix.put(1,2,cy);\r\n\r\n        cameraMatrix.put(2, 0, 0);\r\n        cameraMatrix.put(2,1,0);\r\n        cameraMatrix.put(2,2,1);\r\n    }\r\n\r\n    /**\r\n     * Draw a 3D axis marker on a detection. (Similar to what Vuforia does)\r\n     *\r\n     * @param buf the RGB buffer on which to draw the marker\r\n     * @param length the length of each of the marker 'poles'\r\n     * @param rvec the rotation vector of the detection\r\n     * @param tvec the translation vector of the detection\r\n     * @param cameraMatrix the camera matrix used when finding the detection\r\n     */\r\n    void drawAxisMarker(Mat buf, double length, int thickness, Mat rvec, Mat tvec, Mat cameraMatrix)\r\n    {\r\n        // The points in 3D space we wish to project onto the 2D image plane.\r\n        // The origin of the coordinate space is assumed to be in the center of the detection.\r\n        MatOfPoint3f axis = new MatOfPoint3f(\r\n                new Point3(0,0,0),\r\n                new Point3(length,0,0),\r\n                new Point3(0,length,0),\r\n                new Point3(0,0,-length)\r\n        );\r\n\r\n        // Project those points\r\n        MatOfPoint2f matProjectedPoints = new MatOfPoint2f();\r\n        Calib3d.projectPoints(axis, rvec, tvec, cameraMatrix, new MatOfDouble(), matProjectedPoints);\r\n        Point[] projectedPoints = matProjectedPoints.toArray();\r\n\r\n        // Draw the marker!\r\n        Imgproc.line(buf, projectedPoints[0], projectedPoints[1], red, thickness);\r\n        Imgproc.line(buf, projectedPoints[0], projectedPoints[2], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[0], projectedPoints[3], blue, thickness);\r\n\r\n        Imgproc.circle(buf, projectedPoints[0], thickness, white, -1);\r\n    }\r\n\r\n    void draw3dCubeMarker(Mat buf, double length, double tagWidth, double tagHeight, int thickness, Mat rvec, Mat tvec, Mat cameraMatrix)\r\n    {\r\n        //axis = np.float32([[0,0,0], [0,3,0], [3,3,0], [3,0,0],\r\n        //       [0,0,-3],[0,3,-3],[3,3,-3],[3,0,-3] ])\r\n\r\n        // The points in 3D space we wish to project onto the 2D image plane.\r\n        // The origin of the coordinate space is assumed to be in the center of the detection.\r\n        MatOfPoint3f axis = new MatOfPoint3f(\r\n                new Point3(-tagWidth/2, tagHeight/2,0),\r\n                new Point3( tagWidth/2, tagHeight/2,0),\r\n                new Point3( tagWidth/2,-tagHeight/2,0),\r\n                new Point3(-tagWidth/2,-tagHeight/2,0),\r\n                new Point3(-tagWidth/2, tagHeight/2,-length),\r\n                new Point3( tagWidth/2, tagHeight/2,-length),\r\n                new Point3( tagWidth/2,-tagHeight/2,-length),\r\n                new Point3(-tagWidth/2,-tagHeight/2,-length));\r\n\r\n        // Project those points\r\n        MatOfPoint2f matProjectedPoints = new MatOfPoint2f();\r\n        Calib3d.projectPoints(axis, rvec, tvec, cameraMatrix, new MatOfDouble(), matProjectedPoints);\r\n        Point[] projectedPoints = matProjectedPoints.toArray();\r\n\r\n        // Pillars\r\n        for(int i = 0; i < 4; i++)\r\n        {\r\n            Imgproc.line(buf, projectedPoints[i], projectedPoints[i+4], blue, thickness);\r\n        }\r\n\r\n        // Base lines\r\n        //Imgproc.line(buf, projectedPoints[0], projectedPoints[1], blue, thickness);\r\n        //Imgproc.line(buf, projectedPoints[1], projectedPoints[2], blue, thickness);\r\n        //Imgproc.line(buf, projectedPoints[2], projectedPoints[3], blue, thickness);\r\n        //Imgproc.line(buf, projectedPoints[3], projectedPoints[0], blue, thickness);\r\n\r\n        // Top lines\r\n        Imgproc.line(buf, projectedPoints[4], projectedPoints[5], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[5], projectedPoints[6], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[6], projectedPoints[7], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[4], projectedPoints[7], green, thickness);\r\n    }\r\n\r\n    /**\r\n     * Extracts 6DOF pose from a trapezoid, using a camera intrinsics matrix and the\r\n     * original size of the tag.\r\n     *\r\n     * @param points the points which form the trapezoid\r\n     * @param cameraMatrix the camera intrinsics matrix\r\n     * @param tagsizeX the original width of the tag\r\n     * @param tagsizeY the original height of the tag\r\n     * @return the 6DOF pose of the camera relative to the tag\r\n     */\r\n    Pose poseFromTrapezoid(Point[] points, Mat cameraMatrix, double tagsizeX , double tagsizeY)\r\n    {\r\n        // The actual 2d points of the tag detected in the image\r\n        MatOfPoint2f points2d = new MatOfPoint2f(points);\r\n\r\n        // The 3d points of the tag in an 'ideal projection'\r\n        Point3[] arrayPoints3d = new Point3[4];\r\n        arrayPoints3d[0] = new Point3(-tagsizeX/2, tagsizeY/2, 0);\r\n        arrayPoints3d[1] = new Point3(tagsizeX/2, tagsizeY/2, 0);\r\n        arrayPoints3d[2] = new Point3(tagsizeX/2, -tagsizeY/2, 0);\r\n        arrayPoints3d[3] = new Point3(-tagsizeX/2, -tagsizeY/2, 0);\r\n        MatOfPoint3f points3d = new MatOfPoint3f(arrayPoints3d);\r\n\r\n        // Using this information, actually solve for pose\r\n        Pose pose = new Pose();\r\n        Calib3d.solvePnP(points3d, points2d, cameraMatrix, new MatOfDouble(), pose.rvec, pose.tvec, false);\r\n\r\n        return pose;\r\n    }\r\n\r\n    /*\r\n     * A simple container to hold both rotation and translation\r\n     * vectors, which together form a 6DOF pose.\r\n     */\r\n    class Pose\r\n    {\r\n        Mat rvec;\r\n        Mat tvec;\r\n\r\n        public Pose()\r\n        {\r\n            rvec = new Mat();\r\n            tvec = new Mat();\r\n        }\r\n\r\n        public Pose(Mat rvec, Mat tvec)\r\n        {\r\n            this.rvec = rvec;\r\n            this.tvec = tvec;\r\n        }\r\n    }\r\n}
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/tagdetection/AprilTagDetectionPipeline.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/tagdetection/AprilTagDetectionPipeline.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/tagdetection/AprilTagDetectionPipeline.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/imageprocessing/tagdetection/AprilTagDetectionPipeline.java	
@@ -40,9 +40,9 @@
 public class AprilTagDetectionPipeline extends OpenCvPipeline {
     private long nativeApriltagPtr;
     private Mat grey = new Mat();
-    private ArrayList<AprilTagDetection> detections = new ArrayList<>();
+    private ArrayList<AprilTagDetectionPipeline> detections = new ArrayList<>();
 
-    private ArrayList<AprilTagDetection> detectionsUpdate = new ArrayList<>();
+    private ArrayList<AprilTagDetectionPipeline> detectionsUpdate = new ArrayList<>();
     private final Object detectionsUpdateSync = new Object();
 
     Mat cameraMatrix;
